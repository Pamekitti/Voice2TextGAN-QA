import io
import os
import time
from concurrent.futures import ThreadPoolExecutor
from dataclasses import dataclass

import requests
from moviepy.video.compositing.concatenate import concatenate_videoclips
from moviepy.video.io.VideoFileClip import VideoFileClip


@dataclass
class ExHumanAI:
    api_key: str
    idle_video_url: str

    def __post_init__(self):
        """ Download the idle video """
        idle_video_content = requests.get(self.idle_video_url).content

        # Save the idle video
        os.makedirs('temp', exist_ok=True)
        if os.path.exists('temp/idle.mp4'):
            os.remove('temp/idle.mp4')

        with open('temp/idle.mp4', 'wb') as f:
            f.write(idle_video_content)

        print("Idle video downloaded")

    def generate_video(self, text: str):
        """ Generate a bot video from given text """
        sentences = self._preprocess_text(text)

        index_sentence_pairs = [(i, sentence) for i, sentence in enumerate(sentences)]
        print(f"There are {len(sentences)} sentences...")
        with ThreadPoolExecutor() as executor:
            output_videos = executor.map(self._request_video_from_exhuman_api, index_sentence_pairs)

        final_video = concatenate_videoclips(list(output_videos))
        final_video.write_videofile("temp/final_video.mp4")
        for vdo in output_videos:
            vdo.close()

    def _preprocess_text(self, text: str) -> list[str]:
        """ Preprocess text to fit ExHuman API requirements
        The text should not exceed 200 characters.

        If the text exceeds 200 characters, split the text into sentences and return a list of sentences.

        Args:
            text (str): Text to preprocess

        Returns:
            list[str]: Preprocessed text

        """
        final_sentences = ['']

        if len(text) < 200:
            return [text]
        else:
            sentences = [s for s in text.split('.') if s]

            for each_sentence in sentences:
                if len(final_sentences[-1]) + len(each_sentence) < 200:
                    final_sentences[-1] += f". {each_sentence}"
                elif len(each_sentence) < 200:
                    final_sentences.append(each_sentence)
                else:  # If the sentence is still too long

                    words = each_sentence.split(' ')
                    final_sentences.append('')

                    for each_word in words:
                        if len(final_sentences[-1]) + len(each_word) < 200:
                            final_sentences[-1] += f" {each_word}"
                        else:
                            final_sentences.append(each_word)

            return [s for s in final_sentences if s]

    def _request_video_from_exhuman_api(self, text_and_idx_pair: tuple[int, str]):
        """ Request video from ExHuman API and save it to temp folder

        Args:
            text_and_idx_pair (tuple[int, str]): Tuple of index and text to send to ExHuman API

        Returns:
            video (VideoFileClip): VideoFileClip object of the video generated by ExHuman API

        """
        index, text = text_and_idx_pair

        # Prepare message to send to ExHuman API
        headers = {
            "accept": "application/json",
            "content-type": "application/json",
            "authorization": f"Bearer {self.api_key}"
        }
        payload = {
            "voice_name": "Elon",
            "text": text,
            "idle_url": self.idle_video_url
        }

        # Request video from ExHuman API
        while True:
            time.sleep(0.5)
            response = requests.post("https://api.exh.ai/animations/v3/generate_lipsync", json=payload, headers=headers)
            if b'message' not in response.content:
                print(f"[{index}] Successfully generated video")
                break

        # Save video to file
        video_byte = io.BytesIO(response.content)
        file_name = f"temp/video{index}.mp4"

        if os.path.exists(file_name):
            os.remove(file_name)
        with open(file_name, "wb") as f:
            print(f"Writing video {file_name} to file")
            f.write(video_byte.read())

        return VideoFileClip(file_name)
